use strict;
use warnings;
package Git::Mailmap;

## no critic (Documentation::RequirePodAtEnd)
## no critic (Documentation::RequirePodSections)

use 5.010_000;

# Global creator
BEGIN {
    use parent qw( Exporter );
    our (@EXPORT_OK, %EXPORT_TAGS);
    %EXPORT_TAGS = ();
    @EXPORT_OK   = qw();
}
our @EXPORT_OK;

# Global destructor
END {
}

# ABSTRACT: Command line tools for Iron.io services.

# VERSION: generated by DZP::OurPkgVersion

=head1 STATUS

Package Git::Mailmap is currently being developed so changes in the API and functionality are possible.


=head1 SYNOPSIS

    require Git::Mailmap;
    my $mailmap = Git::Mailmap->new();

=head1 REQUIREMENTS

The Git::Mailmap package require the following packages (in addition to normal Perl core packages):

=over 8

=item Carp::Assert, v. 0.20

=back

=cut

use File::Slurp qw{read_file};
use Log::Any  qw{$log};
use File::Spec qw{read_file};
use File::HomeDir;
use Hash::Util 0.06 qw{lock_keys lock_keys_plus unlock_keys};
use Carp::Assert;
use Carp::Assert::More;
use English '-no_match_vars';
use Params::Validate qw(:all);


=head1 SUBROUTINES/METHODS

=head2 new

Creator function.

=cut

sub new {
    my $class = shift;
    my %params = validate(
        @_, { }, # No parameters when creating object!
    );

    $log->tracef('Entering new(%s, %s)', $class, \%params);
    my $self = {};
    my @self_keys = (
            'committers', # Object's data.
    );
    bless $self, $class;
    $self->{'committers'} = [ ];
    lock_keys(%{$self}, @self_keys);
    $log->tracef('Exiting new: %s', $self);
    return $self;
}

=head2 add

Add new committer.
Params:

=over 8

=item Parameters:

=over 8

=item I<proper-email>, mandatory

=item I<proper-name>, not mandatory

=item I<alias-email>, not mandatory

=item I<alias-name>, not mandatory

=back

=item Return: [NONE]

=back

=cut

sub add {
    my $self = shift;
    my %params = validate(
        @_, {
            'proper-email' => { type => SCALAR, },
            'proper-name' => { type => SCALAR, optional => 1, },
            'commit-email' => { type => SCALAR, optional => 1, },
            'commit-name' => { type => SCALAR, optional => 1, },
        }
    );
    $log->tracef('Entering add(%s)', \%params);
    assert_nonblank( $params{'proper-email'}, 'Parameter \'proper-email\' is a non-blank string' );
    my $committer;
    foreach my $for_committer (@{$self->{'committers'}}) {
        if($for_committer->{'proper-email'} eq $params{'proper-email'}) {
            $for_committer->{'proper-name'} = $params{'proper-name'} if($params{'proper-name'});
            assert_arrayref($committer->{'aliases'}, 'Item \'aliases\' exists.');
            my @aliases = @{$committer->{'aliases'}};
            my $alias;
            foreach my $for_alias (@aliases) {
                if($for_alias->{'commit-email'} eq $params{'commit-email'}) {
                    $for_alias->{'commit-name'} = $params{'commit-name'};
                    $for_alias = $for_alias;
                    last;
                }
            }
            if(! defined $alias) {
                $alias = { 'commit-email' => $params{'commit-email'} };
                $alias->{'commit-name'} = $params{'commit-name'} if($params{'commit-name'});
                push @aliases, $alias;
            }
            $committer = $for_committer;
            last;
        }
    }
    if(! defined $committer) {
        $committer = { 'proper-email' => $params{'proper-email'} };
        $committer->{'proper-name'} = $params{'proper-name'} if($params{'proper-name'});
        $committer->{'aliases'} = [ ];
        my $alias;
        if($params{'commit-email'}) {
            $alias = { 'commit-email' => $params{'commit-email'} };
            $alias->{'commit-name'} = $params{'commit-name'} if($params{'commit-name'});
            push @{$committer->{'aliases'}}, $alias;
        }
        push @{$self->{'committers'}}, $committer;
    }
    return;
}

1;

